## Указатели

В golang есть возможность работать не только с самими переменными, но и с указателями на них.
Для этого есть специальный указательный тип. Его значения -- просто адреса в памяти.

Этот тип всегда имеет такой же размер, что и тип int (т.е. 4 или 8 байт, в зависимости от платформы).
Можно считать, что адрес -- это беззнаковое целое число.

В golang у всего (и у указателей) есть нулевое значение по умолчанию, и для указателей это значение nil.
Значение nil означает заведомо некорректный адрес, т.е. у любой реальной переменной адрес точно не nil.

Примеры действий с указателями:
```go
package main

import "fmt"

func main() {
	var x int = 123 // какая-то переменная
	var p *int = &x // указатель на int, в котором сейчас лежит адрес переменной x

	fmt.Println(p)  // можно распечатать этот адрес
	fmt.Println(*p) // или данные по этому адресу

	*p = 321       // можно изменить значение по этому адресу
	fmt.Println(x) // это отразится на значении соответствующей переменной

	var bad *int // значение указателя равно nil
	*bad = 1 // обращаться по такому указателю нельзя, этот код вызовет панику
}
```

### Стек или куча

Опыт работы с другими ЯП может подсказывать, что при работе с указателями, память, на которую указывают,
выделяется на куче. Но рантайм golang пытается и такие переменные размещать в стеке, когда это возможно.

Для этого используется оптимизация под названием escape analysis. Оптимизация устроена достаточно сложно,
и мы коснёмся её только поверхностно.

Идея оптимизации заключается в том, чтобы проанализировать, куда именно передаётся адрес на ту память,
которая была создана динамически.

Если анализ установил, что переменная не покинет локальную область, то динамическая память будет выделена
на стеке, а не на куче.

Escape analysis выполняется на этапе компиляции; можно увидеть его результаты, добавив при сборке флаг `-gcflag="-m".`,
например:
```bash
go build -gcflags=-m -o main.out main.go
```

### Размер

Обычные (не указательные) типы в golang могут быть насколько угодно большими: структуры могут иметь
десятки и сотни полей, и занимать тысячи байт, и это не предел.

При передаче переменных таких типов без указателя, их значение копируется, и в функцию передаётся копия.
Это (постоянное копирование) может отрицательно повлиять на производительность. Можно использовать указатель,
и тогда при вызове функции будет копироваться не структура размером в тысячи байт,
а указатель размером 4 или 8 байт.

Впрочем, есть и другое мнение. Если данные в функцию переданы по указателю, то с некоторой вероятностью,
этих данных не будет в процессорном кэше, и придётся ходить за ними в оперативную память, что тоже
отрицательно влияет на производительность. 

Общего ответа, что лучше в смысле производительности, нет. Есть общая рекомендация
использовать указатели при передаче "достаточно больших" структур. Конкретный порог размера
определяется параметром линтера и обычно составляет несколько сотен байт.

### Мутабельность

За исключением небольшого количества случаев, если как-то поменять значение параметра внутри функции,
то это изменение не сохранится, когда функция вернёт результат. Это происходит потому что
в функцию передаётся копия значения, и изменения внутри функции выполняются над копией.

Пример. Значение параметра x изменяется внутри функции Sqr, но в функции main оно по-прежнему равно 4.
Хотя результат функции и верный.
```go
package main

import "fmt"

func Sqr(x int32) int32 {
	x = x * x
	return x
}

func main() {
	var x int32 = 4
	var y = Sqr(x)

	fmt.Println("y = ", y, "x = ", x)
}
```

Если хочется добиться такого эффекта, чтобы функция могла менять значение, и это изменение сохранялось,
необходимо использовать указатели.

То же самое необходимо делать в функциях-ресиверах, если есть цель изменить значение типа,
к которому относится функция.

```go
package main

import "fmt"

type Slice struct {
	data []int
}

func (s Slice) BadAppend(val int) {
	s.data = append(s.data, val)
}

func (s *Slice) GoodAppend(val int) {
	s.data = append(s.data, val)
}

func main() {
	s := Slice{}

	s.BadAppend(1)
	fmt.Println(s) // {[]}

	s.GoodAppend(2)
	fmt.Println(s) // {[2]}
}
```

### Значение nil

Если по каким-то причинам, значение переданного указателя равно nil,
то любая попытка обращения по этому указателю вызовет ошибку.

Имеет смысл всегда проверять значение указателя на nil перед обращением. Это касается и функций-ресиверов.

Примеры кода, который вызовет панику:
```go
// 1
var p *int
*p = 1

// 2
func acceptsIntPtr(p *int) int {
    val := *p
    return val * val
}

var p *int
acceptsIntPtr(p)

// 3
type Slice struct {
    data []int
}

func (s *Slice) Len() int {
    return len(s.data)
}

var s *Slice
fmt.Println(s.Len())
```

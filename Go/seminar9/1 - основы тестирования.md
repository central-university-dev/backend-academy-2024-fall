- [Основы тестирования в golang (пакет testing)](#основы-тестирования-в-golang-пакет-testing)
  - [Функции тестирования](#функции-тестирования)
  - [Именование пакета](#именование-пакета)
  - [Жизненный цикл теста](#жизненный-цикл-теста)
  - [Параллельный запуск](#параллельный-запуск)
  - [Остальное](#остальное)

# Основы тестирования в golang (пакет testing)

## Функции тестирования

Как и во многих других ЯП, тестирование в golang представляет собой запуск специального кода, который написан 
на том же самом языке. Задача этого специального кода (тестов) -- проверить те или иные аспекты работы
приложения.

Файлы с кодом тестов чаще всего находятся в тех же папках (пакетах), что и файлы с "основным" кодом приложения,
поэтому код тестов должен соответствовать специальному формату.

Код тестов должен располагаться в файлах, имя которых заканчивается на `_test`. Можно называть файл с тестами
таким же образом, как и файл с тестируемым кодом, например: `runner.go` и `runner_test.go`, но это не обязательно;
главным условием является окончание имя файла. Любой код, который находится в таких файлах, не учитывается 
при сборке приложения (`go build`).

[Директория с примером](./examples/part1/badtestcode). В `file_with_test.go` есть синтаксически некорректная конструкция,
но она не мешает запустить функцию main из файла `main.go`. Если написать такую же некорректную конструкцию в файле
без окончания `_test`, то запустить main уже не получится.

Каждый тест должен быть оформлен в виде функции, имя которой начинается со слова `Test`, а единственным параметром этой
функции должно быть `t *testing.T`. В файлах с тестами могут быть и другие функции (вспомогательные), но тестами
(функциями тестирования) считаются только функции, которые соответствуют этому формату.

## Именование пакета

Как и все файлы с исходным кодом в golang, файл с тестами должен относиться к какому-то пакету. Как правило,
файлы с тестами располагаются в одной **директории** с файлами кода приложения, поэтому пакет должен называться
либо таким же образом, либо с суффиксом `_test`. 

Разница в том, что во втором случае будет считаться, что тесты являются **отдельным** пакетом, и из кода тестов
не будет доступа к приватным типам/функциям/переменным пакета, который тестируется. Этот подход называется 
`blackbox testing`.

В первом случае будет считаться, что тесты располагаются в том же пакете, что делает возможным доступ к приватным
сущностям. Такой подход называется `whitebox testing`.

Рекомендуется следовать blackbox-подходу и избегать whitebox-тестирования. Когда код из пакета будет использоваться
в реальном приложении, у вызывающих его функций не будет доступа к деталям реализации; те же ограничения правильнее
соблюдать и при проверке (тестировании).

[Пример whitebox](./examples/part1/whitebox)

[Пример blackbox](./examples/part1/blackbox)

## Жизненный цикл теста

Тесты запускаются с помощью `go test`. В качестве аргумента можно передать пакет или список пакетов.
Эта команда найдёт в переданных пакетах все функции тестирования и запустит их.

Задача каждой функции тестирования -- запустить кусок кода приложения и проверить правильность его работы: что функции 
возвращают результаты, ожидаемые для того списка параметров, с которыми их вызвали. Если результаты будут отличаться
от ожидаемых, то это требуется отметить как ошибки; в таком случае будет считаться, что тест не прошёл.

Чтобы вызвать ошибку теста, есть функции-ресиверы `t.Fatal`/`t.Fatalf` и `t.Error`/`t.Errorf`. Разница между
ними в том, что `t.Fatal(f)` останавливают выполнение функции тестирования при первой встреченной ошибке,
а `t.Error(f)` отмечают тест как непрошедший, но продолжают выполнение функции тестирования, 
что позволяет собрать все ошибки.

[Различия Fatal(f) и Error(f)](./examples/part1/failingtests)

Если в ходе выполнения функции тестирования не было отмечено ошибок, то тест считается успешно пройденным. 

В ходе выполнения не должно происходить паник. Если всё же в тестируемом коде есть места, 
где вызывается паника, то:

- так делать плохо, вас будут осуждать
- то, что паника вызывается, тоже нужно проверить в тестах

[Тестирование паники](./examples/part1/codethatpanics)

## Параллельный запуск

Функции тестирования могут запускаться параллельно, но для этого её нужно явным образом объявить готовой
к этому, с помощью вызова `t.Parallel()`. Кроме этого, внутри функции тестирования можно запускать
вложенные тесты (subtest), которые тоже можно запустить параллельно с остальными.

Для этого, тест-кейсы внутри функции тестирования оформляют в виде коллекции (слайс/массив, иногда map)
структур определённого типа (т.н. "табличные тесты").

[Параллельный запуск табличных тестов](./examples/part1/parallel)

## Остальное

Для отладки функций тестирования можно использовать `t.Log` (логирование в функции тестирования). 

Отдельные тест-кейсы можно пропускать (например, в зависимости от ОС) с помощью `t.Skip()`.
